1) inheritance
2) overloading
3) overriding
4) abstract class
5) abstract method
6) interface

consider the following classes 

abstract class Shape
{
	public abstract calculateArea();	
}

class Triangle extends Shape
{
	public void calculateArea()
	{
		System.out.println("0.5 * b *h");
	}
}

class Rectangle extends Shape
{
	public void calculateArea()
	{
		System.out.println("l * b");
	}
}

class Circle extends Shape
{
	public void calculateArea()
	{
		System.out.println("3.14f * r * r");
	}
}


import java.util.Scanner;

public class App {

	public static void main(String[] args) {
		Shape s=null;		//what is s? s is a ref var 
		System.out.println("1: Triangle\r\n"
				+ "2: Rectangle\r\n"
				+ "3: Circle\r\n"
				+ "x: Exit");
		Scanner sc=new Scanner(System.in);
		int choice=0;
		
		do
		{
			choice=sc.nextInt();
			switch(choice)
			{
			case 1:		//triangle
				s=new Triangle();
				break;
			case 2:		//rectangle
				s=new Rectangle();
				break;
			case 3:		//circle
				s=new Circle();
				break;
			}
			s.calculateArea();
		}while(choice<=3 && choice>=1);
	}

}



1) abstract class cannot be instantiated
	create an object is called instantiated
2) only abstract class/ interface can contain abstract methods
3) abstract class can contain methods with body also.
4) if a class class does not override the abstract method of super class, then sub class must be declared abstract.

interface
----------




interface A
interface B

class C implements A, B

interfaces
	provide highest level of abstraction
	uptio 1.7 version of java, interfaces, never allowed methods with body
	from 1.8 onwards, interfaces can have
		abstract methods
		static methods with body		(<<interfacename>>.methodname())
		default methods with body		
	you cannot create object of interface
		but create objects of classes that implements interfaces



interface Shape

class Triangle implements Shape

class Rectangle implements Shape


public class App
{
	public void draw(Shape s)		//s=new Triangle		s=new Rectangle
	{
		s.drawShape();
	}
}

s=new Triangle();
s=new Rectangle();

Abstract class vs Interface
--------------------------------
OOPS
	inheritance
	encapsulation & abstraction		(getters and setters, non public data members
	polymorphis			(overloading, overriding)


overriding rules
	1) super class method and sub class method are same name
	2) super class method and sub class method are same signature
	3) super class method and sub class method have same return type
	4) sub class method cannot reduce visibility	
		means, 
		if super class method is public, then sub class method must be public only
		if super class method is protected, then sub class method must be public, protected
		if super class method is default, then sub class method must be public, protected, default

private members of a class are not availble to sub classes.
	

acces specifiers
	public 	
	protected
	default
	private


public:
	accessible everywhere
	
protected:
	accessible within same package
	accessible from sub classes of same or any package

default:
	accessible within same package

private:
	accessible within same class only


what is a package?
	group of classes and interfaces

void display()			no access specifier, then it is default scope. they are package scope


Activity:
	packages
	diff between interfaces and abstract class


interface:
-----------
can contain
	constants.	implicitly public static final		data members



interface Person
{
	public static final int MAX_MARKS=100;
	int MIN_MARKS=0;
	void speak();
	public void run();
}

class Employee implements Person
{
	public void speak()
	{
		System.out.println("Employee speaks");
	}
}

class App
{
	public static void main(String args[])
	{
		Employee raja=new Employee();
		raja.speak();		//what is the output
	}
}

interface
	contains datamembers as 	public static final
		they must be initialized with a value
		even if we do not mention public static final, also, they are public static final
	methods, data members, all are public only.

	methods in interface
		can be
			abstract (do not mention as abstract, but they are abstract)
			default	(with body)	java 1.8 onwards
			static	(with body)	java 1.8 onwards




Activity:
-----------
understand
	abstract class
	interface
	difference between abstract class and interfaces
	overriding rules
	access specifiers




Regular expressions
--------------------------

suppose you get a message like this
	"Kindly contact 9898989898 and if it is not reachable, contain 3737373737"

we are able to extract only the numbers from this message.

RegEx in java, can allows us to
	extract the portions of the string, that matches a pattern	
	or
	check if a string matches a pattern or not		(true or false)

Demo:
lets see an example to validate if the given string matches the following pattern or not.
	pattern:		Employee id must be 		E followed by 3 digit number
	ex:
			E001
			E102

REGULAR EXPRESSION SYMBOLS:
--------------------------------------
there are 2 portions in each expression

pattern and multiplicity
ex:
	\d+

\d means digit
+ means 1 or more

\d{1,3}
means		digit, that occur 	atleast once and max 3 times	

	1 to 3 digits	

same can be done as

[0-9]{1,3}

[]	square brackets can be used for 
	i) range		[a-z]
	ii) list of character from which 1 can occur
		[aeiou]		either of the characters in the list

	[0-9A-Za-z]		either a number or lower or upper case alphabet


()	normal brackets for grouping operations

\D	non digit

+	1-more
*	0-more
?	0-1
{x,}	min x
{,x}	max x
{3}	only 3 times

String []arr=str.split("[.]");



import java.util.Scanner;

public class EmailDemo {

	public static void main(String[] args) {
		String input=new Scanner(System.in).next();
		String pattern="[A-Za-z]+([.][A-Za-z0-9]+)?@[A-Za-z]+[.]([A-Za-z]{2,3}|[A-Za-z]{2}[.][A-Za-z]{2})";
		System.out.println((input.matches(pattern))?"Valid email":"Invalid email");
	}

}




import java.util.Scanner;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegexExtract {

	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		String input=sc.nextLine();
		
		Pattern p = Pattern.compile("[A-Za-z]+([.][A-Za-z0-9]+)?@[A-Za-z]+[.]([A-Za-z]{2,3}|[A-Za-z]{2}[.][A-Za-z]{2})");
		Matcher matcher = p.matcher(input);
		while(matcher.find())
		{
			System.out.println(matcher.group());
		}		
	}

}



------------------
Exception Handling
---------------------
What is exception?
	During the execution of the program, during runtime
	is an abnormal event that occurs and affects the normal flow of execution
	in such cases, the program terminates abruptly

	are means of communication from the person who created the method
	that something is abnormal, the calling method has to handle that

	
What is exception handling?
	providing the program, an alternate path to continue, when exception occurs.
	by handling exception, we avoid termination of the program


in java,
	every exception is represented by a class

the super class for all exception classes is "Exception" class

Object
	-> Throwable
		-> Error		(cannot handle. Termination is the only solution)
		-> Exception	(can be handled using try-catch blocks)

Exception 
	-> RuntimeException 

All classes, derived from RuntimeException class
	are called as unchecked exceptions
	they are not checked by compiler
	they are visible at runtime

All classes, derived from Exception
	are called as checked exception
	they are checked by compiler



checked exceptions
	compiler will except
		either you handle the exception or
		declare with throws
	

throws
	informs the compiler, that this method throws these checked exceptions, 
	but does not handle. The calling method must handle them

throw
	is used to throw an object of exception



try block
catch block
finally block

try-catch
try-catch-finally
try-catch-catch-finally
try-finally

finally block is always executed whenever, try block is executed


How to create user defined exception class?


throw new Employee();		//not allowed, because, Employee is not throwable

If you create a class that inherites Exception or its sub class (except RuntimeException) is an user defined checked exception

If you create a class that inherits RuntimeException or its sub class, is an user defined unchecked exception

the class you create, should ideally have a constructor like this

public class InvalidAmountException extends Exception
{
	public InvalidAmountException(String message)
	{
		super(message);
	}
}


try
catch(Exception ex)
{
	ex.getMessage());
}

Task:
-------
create an Employee class
	id Integer
	name String
	dob java.util.Date

the setter methods validate the data and throw apporpriate exceptions

rules:
	id must be 6 digit number
		if not, InvalidIdException
	name must begin with upper case and followed by lower case
		minimum 4 characters
		if not, InvalidNameException
	dob must be past tense only
		if not, InvalidDobException

while throwing exception, 
	mention the invalid value also in the message.
	ex:
		The id "121" is invalid


in App.java
	main method
		create the object of Employee and set the values and 
		at runtime, the exceptions must be handled


123456, Rama, 27-Aug-2024


The solution is pushed to git
check this 
folder in java
	26-aug-exceptions-demo


-------------------------------------------------------------------------------------
Collections
----------------
There are the limitations of array?
	array length cannot be changed once created.
	static memory allocation
	array elements are present in contiguous memory locations


to overcome these limitations,
	we use collections 

collections allow us to create

ArrayList
LinkedList
Vector
Stack


HashSet
TreeSet
LinkedHashSet



Map		is an application of Collection

HashMap
TreeMap
LinkedHashMap


Suppose, you are creating method like this

	public int[] primes(int from, int to)
	{
		//return an array that contains, all the prime numbers between from and to
		//write your code here	

		//store each prime number in ArrayList		
	}


Demo:
	
input format:

from:	22
to:	122

display all magic prime numbers

a magic prime number is a prime number, whose each digit is prime.


ifPrime(x)



import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;

public class MagicPrime {

	public static boolean isPrime(int num)
	{
		if(num<2)
			return false;
		if(num==2)
		{
			return true;
		}
		for(int denom=2;denom<=Math.sqrt(num);denom++)
		{
			if(num%denom==0)
			{
				return false;
			}
		}
		return true;
	}
	
	public static int[] primes(int from, int to)
	{
		ArrayList<Integer> list=new ArrayList<>();
		for(int i=from;i<=to;i++)
		{
			if(isPrime(i))
			{
				list.add(i);
			}
		}
		int[] arr= new int[list.size()];
		for (int i = 0; i < arr.length; i++) {
		    arr[i] = list.get(i);
		}
		
		return arr;
	}
	
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		int from=sc.nextInt();
		int to=sc.nextInt();
		
		int[] result = primes(from, to);
		
		System.out.println(Arrays.toString(result));
	}

}

List vs Set

List
	allows duplicate elements
	allows any number of nulls
	is ordered, it remembers the order in which elements are added

Set
	rejects duplicate elements
	one null is allowed, another null is rejected as duplicate
	set order is based on the type of set
		HashSet uses order based on hashCode method
		TreeSet sorts the elements based on Comparable/ Comparator
		LinkedHashSet maintains elements in the same order in which they are added (similar to List)



Task:
------
University Requirement 2
------------------------------
