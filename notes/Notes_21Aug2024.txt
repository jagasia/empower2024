Basics, Normalization, SQL(DDL, DML, TCL, DRL, DCL) Commands, Joins
Select statement with all clauses, Set Operators, Predefined functions, Indexs, Views
PL/SQL Basics, Cursors, Procedures, Functions, Triggers
Pending so far:
Normalization
Index
View
---------------
Normalization is a scientific, systematic, step by step approach for designing database tables
so far, we have used the following tables:
HR.EMPLOYEES
HR.DEPARTMENTS

CUSTOMER
ACCOUNT
BRANCH
TRANDETAILS
LOAN

LOAN

Normalization aims to reduce the redundancy
What is redundancy?
	Unnecessary repeatation of data

Table once we arrived from E-R diagram can be found as large table
that large table can be moved to 1NF when
every row has only 1 data.
every data is atomic

2 NF
already the table should be in 1NF and then all attributes are functionally dependent on whole table


CUSTOMER
CID	NAME	DNO	STREET	CITY	PINCODE	STATE		COUNTRY
1	Raja	1	MG Road	Bengaluru	500068	KARNATAKA	INDIA


1NF
2NF
3NF
BCNF

Index
	enforce uniqueness
	is useful only when we use SELECT statement using condition on indexed column

SELECT * FROM HR.EMPLOYEES WHERE UPPER(JOB_ID)='HR_EXEC';

create index idx1 on CUSTOMER(CID, FNAME);

VIEWS
----------
Query is not a database object
Views are like stored queries

CREATE VIEW vw1
AS
SELECT * FROM HR.EMPLOYEES WHERE DEPARTMENT_ID=90;

SELECT * FROM vw1;


CAN YOU UPDATE a VIEW?
	UPDATE statement?

SELECT DEPARTMENT_ID, SUM(SALARY)
    FROM HR.EMPLOYEES 
    GROUP BY DEPARTMENT_ID
having sum(salary)=
(select max(t1.total) from (select department_id did, sum(salary) total from hr.employees group by department_id) t1)

DML on views 
	are allowed if it affects column(s) of a single underlying table
	are not allowed if it affects computed column or derived column
	are not allowed if view uses group by
	
Task:
Create a view that returns the department and the total number of employees in that department (vwNoOfEmps)
Create a query that returns the department which has highest number of employees.

Identify the conditions when DML is allowed on views

	
CREATE VIEW vwNoOfEmps 
AS
SELECT DEPARTMENT_ID, COUNT(EMPLOYEE_ID) Total
FROM HR.EMPLOYEES 
GROUP BY DEPARTMENT_ID;

select DEPARTMENT_ID, TOTAL from vwNoOfEmps
    WHERE TOTAL=(SELECT MAX(TOTAL) FROM vwNoOfEmps);

CREATE VIEW vwDept
    AS
SELECT * FROM HR.DEPARTMENTS;

INSERT INTO VWDEPT VALUES(280,'Personal', null, 1700);



https://github.com/oracle-samples/db-sample-schemas/tree/main/human_resources
you can run
	hr_create.sql
	hr_populate.sql

for getting hr schema in your oracle database.
--------------------------------------------------------------
PL/SQL
----------
Procedural Language extension to SQL
SQL limitations
	increases traffic when multiple statements are sent to oracle server
	procedural capabilities like CONDITIONS, LOOPS, VARIABLES, EXCEPTION HANDLING are missing in SQL

The block structure of PLSQL:
	DECLARE		//optional block
	BEGIN
	EXCEPTION	//optional block
	END;




example:
BEGIN
    DBMS_OUTPUT.PUT_LINE('Hello world');
END;


in livesql, the output is always turned on. so we get output.
in most of oracle clients, server output is turned off. by default.

so we can turn 

SET SERVEROUTPUT ON;

DBMS_OUTPUT is a package that contains functions and procedures related to output.
we use a procedure PUT_LINE which is present in this package.

Data types
	we can create variables and constants in a plsql program

DECLARE
    X INT:=20;
BEGIN
    X:=X+1;
    DBMS_OUTPUT.PUT_LINE(X);
END;



BEGIN
	SELECT * FROM HR.EMPLOYEES;
END;
The above plsql program does not execute successfully because, in PLSQL, select statements should have INTO clause.
---------------------------------
DECLARE
    X INT;
BEGIN
	SELECT SALARY INTO X FROM HR.EMPLOYEES;
	DBMS_OUTPUT.PUT_LINE(X);
END;

The  above program produces error because, select query returns more than 1 row.

Finally

DECLARE
    X INT;
BEGIN
	SELECT SALARY INTO X FROM HR.EMPLOYEES;
	DBMS_OUTPUT.PUT_LINE(X);
END;


This worked.
-------------------------
Instead of specifying a type to the variable,
can we use refering the type from a column

DECLARE
    X HR.EMPLOYEES.SALARY%TYPE;
BEGIN
	SELECT SALARY INTO X FROM HR.EMPLOYEES WHERE EMPLOYEE_ID=100;
	DBMS_OUTPUT.PUT_LINE(X);
END;

-0----------------------------
if i want to retrieve entire row and store it in a variable?

DECLARE
    X HR.EMPLOYEES%ROWTYPE;
BEGIN
	SELECT * INTO X FROM HR.EMPLOYEES WHERE EMPLOYEE_ID=100;
	DBMS_OUTPUT.PUT_LINE(X.FIRST_NAME || ' '|| X.SALARY);
END;


Sometime, we use select statement like this

SELECT EMPLOYEE_ID, FIRST_NAME, SALARY
FROM HR.EMPLOYEES 
WHERE EMPLOYEE_ID=100;

In that case:

DECLARE
    EID INT;
	FNAME VARCHAR2(45);
	SAL INT;
BEGIN
	SELECT EMPLOYEE_ID, FIRST_NAME, SALARY 
    	INTO EID, FNAME, SAL
	FROM HR.EMPLOYEES 
	WHERE EMPLOYEE_ID=100;
	DBMS_OUTPUT.PUT_LINE(EID);
	DBMS_OUTPUT.PUT_LINE(FNAME);
	DBMS_OUTPUT.PUT_LINE(SAL);
END;

The same can be done with an user defined type record variable
DECLARE
	TYPE EMPREC IS RECORD(
    	EID INT,
    	FNAME VARCHAR2(45),
    	SALARY INT
    );
	X EMPREC;
BEGIN
	SELECT EMPLOYEE_ID, FIRST_NAME, SALARY 
    	INTO X
	FROM HR.EMPLOYEES 
	WHERE EMPLOYEE_ID=100;
	DBMS_OUTPUT.PUT_LINE(X.EID);
	DBMS_OUTPUT.PUT_LINE(X.FNAME);
	DBMS_OUTPUT.PUT_LINE(X.SALARY);
END;
----------------------
Task:
----------
1) Write a plsql program to find the number of employees in department 90.
Store the result in a variable and print it.
Solution:
DECLARE
    N INT;
BEGIN
    SELECT COUNT(EMPLOYEE_ID) INTO N FROM HR.EMPLOYEES
    WHERE DEPARTMENT_ID=90;
	DBMS_OUTPUT.PUT_LINE(N);
END;

2) Write a plsql program to find the manager of employee whose id is 110.
Display the manager name.

DECLARE
    MID HR.EMPLOYEES.EMPLOYEE_ID%TYPE;
	MNAME HR.EMPLOYEES.FIRST_NAME%TYPE;
BEGIN
    SELECT MANAGER_ID INTO MID
    FROM HR.EMPLOYEES
    WHERE EMPLOYEE_ID=110;
	SELECT FIRST_NAME INTO MNAME
        FROM HR.EMPLOYEES 
        WHERE EMPLOYEE_ID=MID;
	DBMS_OUTPUT.PUT_LINE(MNAME);
END;

The same is done without plsql in below method:
SELECT M.FIRST_NAME MNAME
FROM HR.EMPLOYEES E JOIN HR.EMPLOYEES M
    ON E.MANAGER_ID=M.EMPLOYEE_ID
WHERE E.EMPLOYEE_ID=110;


3) Write a plsql program to store the 
	employee first name
	department name
	salary
where the employee id =111
hint:	
	use user defined record type
Solution:
DECLARE
    DID HR.DEPARTMENTS.DEPARTMENT_ID%TYPE;
	DNAME HR.DEPARTMENTS.DEPARTMENT_NAME%TYPE;
    TYPE REC IS RECORD(
    	FNAME HR.EMPLOYEES.FIRST_NAME%TYPE,
    	DNAME HR.DEPARTMENTS.DEPARTMENT_NAME%TYPE,
    	SAL HR.EMPLOYEES.SALARY%TYPE
    );
	X REC;
BEGIN
    SELECT DEPARTMENT_ID INTO DID 
    FROM HR.EMPLOYEES WHERE EMPLOYEE_ID=111;
	SELECT DEPARTMENT_NAME INTO DNAME
        FROM HR.DEPARTMENTS 
        WHERE DEPARTMENT_ID=DID;
    SELECT FIRST_NAME, NULL, SALARY INTO X FROM HR.EMPLOYEES WHERE EMPLOYEE_ID=111;
	X.DNAME:=DNAME;
	DBMS_OUTPUT.PUT_LINE(X.FNAME);
	DBMS_OUTPUT.PUT_LINE(X.DNAME);
	DBMS_OUTPUT.PUT_LINE(X.SAL);
END;

4) retrieve the row based on employee id 112 and store it in a row type variable
	and display only the firstname and salary

Solution:
DECLARE
    EMPREC HR.EMPLOYEES%ROWTYPE;
BEGIN
    SELECT * INTO EMPREC
    FROM HR.EMPLOYEES 
    WHERE EMPLOYEE_ID=112;
	DBMS_OUTPUT.PUT_LINE(EMPREC.FIRST_NAME);
	DBMS_OUTPUT.PUT_LINE(EMPREC.SALARY);
END;

--------------------------------------------
Procedural capabilities/ programming constructs

IF
IF ELSE
IF ELSIF ELSE
SELECT CASE
BASIC LOOP
WHILE LOOP
FOR LOOP




DECLARE
    X INT:=100;
BEGIN
    IF X > 50 THEN
    	DBMS_OUTPUT.PUT_LINE('Higher');
    END IF;
END;

if condition with else
DECLARE
    X INT:=50;
BEGIN
    IF X > 50 THEN
    	DBMS_OUTPUT.PUT_LINE('Higher');
	ELSE
        DBMS_OUTPUT.PUT_LINE('Lower');
    END IF;
END;





DECLARE
    X INT:=510;
BEGIN
    IF X > 50 THEN
    	DBMS_OUTPUT.PUT_LINE('Higher');
		DBMS_OUTPUT.PUT_LINE(' than 50');
	ELSE
        DBMS_OUTPUT.PUT_LINE('Lower');
		DBMS_OUTPUT.PUT_LINE(' than 50....');
    END IF;
END;


Task:
-------
Write a plsql program to determine the grade of the employees based on salary
SALARY
	>20,000		A
	>10,000 <=20,000	B
	>5,000 <=10,000	C
	otherwise		D

salary variable is assigned a value and tested

Hint: 
use ELSIF	

Solution:
DECLARE
    SALARY INT:=10000;
BEGIN
    IF SALARY>20000 THEN
    	DBMS_OUTPUT.PUT_LINE('A');
	ELSIF SALARY>10000 THEN
        DBMS_OUTPUT.PUT_LINE('B');
	ELSIF SALARY>5000 THEN
        DBMS_OUTPUT.PUT_LINE('C');
	ELSE
        DBMS_OUTPUT.PUT_LINE('D');
	END IF;
END;

-----------------------------------------------
select case
--------------
Syntax:
	SELECT COL1, COL2,.....
	CASE EXP
	WHEN VALUE1 THEN <<WHATTODO>>
	.....
	.....
	ELSE	<<WHATTODO>>
	END
FROM <<TABLENAME>>.....



SELECT ACNUMBER, TRANSACTION_TYPE, TRANSACTION_AMOUNT, 
CASE TRANSACTION_TYPE WHEN 'Deposit' THEN TRANSACTION_AMOUNT
    WHEN 'Withdrawal' THEN TRANSACTION_AMOUNT*-1
    END
    FROM TRANDETAILS;





SELECT T1.ACNUMBER, SUM(AMT) FROM 
    (SELECT ACNUMBER, TRANSACTION_TYPE, TRANSACTION_AMOUNT, CASE TRANSACTION_TYPE WHEN 'Deposit' THEN TRANSACTION_AMOUNT
    WHEN 'Withdrawal' THEN TRANSACTION_AMOUNT*-1
    END AMT
    FROM TRANDETAILS) T1
GROUP BY T1.ACNUMBER;



A00001	-3000
A00002	-2000
A00007	14000
----------------------
In PLSQL, we can also use SELECT CASE statements

declare
    X CHAR:='A';
begin
    CASE X
    WHEN 'A' THEN
    	DBMS_OUTPUT.PUT_LINE('Excellent');
	WHEN 'B' THEN
        DBMS_OUTPUT.PUT_LINE('Good');
	END CASE;
end;
-------------------------------
declare
    X CHAR:='A';
begin
    CASE 
    WHEN x='A' THEN
    	DBMS_OUTPUT.PUT_LINE('Excellent');
	WHEN x='B' THEN
        DBMS_OUTPUT.PUT_LINE('Good');
	END CASE;
end;

Challenge:
----------------
Write a plsql program to find the account balance of an account by acnumber

DECLARE
    deposits int;
	withdrawals int;
	ano char(6):='A00001';
BEGIN
    SELECT SUM(TRANSACTION_AMOUNT) INTO deposits
    FROM TRANDETAILS WHERE ACNUMBER=ano
    AND TRANSACTION_TYPE='Deposit';
    SELECT SUM(TRANSACTION_AMOUNT) INTO withdrawals
    FROM TRANDETAILS WHERE ACNUMBER=ano
    AND TRANSACTION_TYPE='Withdrawal';
	DBMS_OUTPUT.PUT_LINE(deposits-withdrawals);
END;

-----------------------------------------
Basic Loop in PLSQL
---------------------------
DECLARE
	X INT:=1;
BEGIN
    LOOP
    	DBMS_OUTPUT.PUT_LINE(X);
		X:=X+1;
		EXIT WHEN X=10;
    END LOOP;
END;


What is WHILE LOOP?
DECLARE
	X INT:=1;
BEGIN
    WHILE X<10
    LOOP
    	DBMS_OUTPUT.PUT_LINE(X);
		X:=X+1;
		-- EXIT WHEN X=10;
    END LOOP;
END;

---------------------------
FOR LOOP
---------------
DECLARE
	X INT;
BEGIN
	FOR X IN 1 .. 9
    LOOP
    	DBMS_OUTPUT.PUT_LINE(X);
		-- X:=X+1;
		-- EXIT WHEN X=10;
    END LOOP;
END;


Task:
-------
Write a plsql program to display the 
	FIRST_NAME
	SALARY
of employees whose ID between 
	100 and 200

you can use
	basic loop
	while loop
	for loop



DECLARE
    FNAME HR.EMPLOYEES.FIRST_NAME%TYPE;
	SAL HR.EMPLOYEES.SALARY%TYPE;
	X INT:=100;
BEGIN
	LOOP
        SELECT FIRST_NAME, SALARY INTO FNAME, SAL
    	FROM HR.EMPLOYEES
    	WHERE EMPLOYEE_ID=X;
		DBMS_OUTPUT.PUT_LINE(FNAME || ' '|| SAL);
		X:=X+1;
		EXIT WHEN X>=120;
    END LOOP;
END;

-----------------using while loop---------------
DECLARE
    FNAME HR.EMPLOYEES.FIRST_NAME%TYPE;
	SAL HR.EMPLOYEES.SALARY%TYPE;
	X INT:=100;
BEGIN
	WHILE X<=120
    LOOP
        SELECT FIRST_NAME, SALARY INTO FNAME, SAL
    	FROM HR.EMPLOYEES
    	WHERE EMPLOYEE_ID=X;
		DBMS_OUTPUT.PUT_LINE(FNAME || ' '|| SAL);
		X:=X+1;		
    END LOOP;
END;

----------------------------
using for loop:
DECLARE
    FNAME HR.EMPLOYEES.FIRST_NAME%TYPE;
	SAL HR.EMPLOYEES.SALARY%TYPE;
	X INT;
BEGIN
	FOR X IN 100 .. 120
    LOOP
        SELECT FIRST_NAME, SALARY INTO FNAME, SAL
    	FROM HR.EMPLOYEES
    	WHERE EMPLOYEE_ID=X;
		DBMS_OUTPUT.PUT_LINE(FNAME || ' '|| SAL);
    END LOOP;
END;



----------------------------------
So far, we have created PLSQL programs that are executed, 
but not stored in the database as object.

These are called as anonymous blocks

then what are named blocks?
	they are stored in the database as objects and they have name

ex:
	PROCEDUREs
	FUNCTIONs

are named plsql blocks.

PROCEDURES
--------------------
Procedures in plsql are db objects and they are stored plsql programs.
we can also call them as Stored Procedures

How to create a procedure
	CREATE PROCEDURE


CREATE PROCEDURE PRC1
AS
BEGIN
  DBMS_OUTPUT.PUT_LINE('Hi this is prc1 procedure');  
END;
procedure created.

How to call the procedure?
BEGIN
    PRC1;
END;

You can call a Procedure from
	a plsql block
	a procedure
	a function
	a trigger




scanf("%d",&x);



printf(x);




create or replace procedure prcAkil(x int, y out int)
as
begin
    y:=x*x;
end;

what will happen:
create or replace procedure prcAkil(x int, y out int)
as
begin
    y:=x*x;
end;
------------------------------------------
declare
    result int;
begin
    prcAkil(2, result);
	dbms_output.put_line(result);
end;


------------------------
Challenge:
Create a plsql procedure to accept employee_id and
return the full name  (combination of first and last name)
and salary
the outputs must be stored in output parameters

call the procedure from a plsql program and 
display the outputs obtained while calling the procedure

CREATE OR REPLACE PROCEDURE PRC2(EID INT, NAME OUT VARCHAR2, SALARY OUT INT)
AS
BEGIN
    SELECT SALARY, FIRST_NAME || ' ' || LAST_NAME
    INTO SALARY, NAME
    FROM HR.EMPLOYEES 
    WHERE EMPLOYEE_ID=EID;
END;

Call the above procedure from a plsql program:
DECLARE
    SAL INT;
	NAME VARCHAR2(100);
BEGIN
    PRC2(100, NAME, SAL);
	DBMS_OUTPUT.PUT_LINE(SAL);
	DBMS_OUTPUT.PUT_LINE(NAME);
END;
-------------------------------------------
Functions
----------------
Functions must return a single value

CREATE OR REPLACE FUNCTION FN1
RETURN NUMBER
AS
BEGIN
    RETURN 100;
END;

Create a function that accepts the employee id as input parameter and return the bonus
Bonus will be 10% of the salary.

create or replace function fnBonus(eid int)
return number
as
    bonus number(6,2);
begin
    select salary * 0.1 INTO bonus
    from hr.employees where employee_id=eid;
	return bonus;
end;

now, lets call this function

 

select employee_id, salary, fnBonus(employee_id)
from hr.employees;


select fnBonus(100) from dual;

Challenge:
-------------
Create a function fnName, that accepts employee id as 
input and returns the full name as output.

call this function as follows

select employee_id, fnName(employee_id)
from hr.employees.
