Yesterday, we learned 
DDL
DML
DCL
TCL

Today, we learn DQL
Data Query Language
Data Retrieval Language
SELECT statement
	to retrieve data from the table(s)

yesterday we used simple SELECT statements
	
ex:
	SELECT * FROM PRODUCT;

What is this *?
	all columns

SELECT * FROM PRODUCT
	retrieves all rows and all columns
	but * means all columns

	we get all rows, because, we haven't specified any condition

SELECT * FROM PRODUCT WHERE ID=23;
	//here, we retrieve rows where ID is 23

Relational Operators:
------------------------------
PROJECTION
	projecting only the relevant columns
SELECTION
	selecting only the relevant rows
UNION
	combining rows from 2 relation, and common rows are shown only once
	duplicates are displayed only once, so 5 + 8 was 11	(2 duplicates)
UNION ALL
	combining rows from 2 relation, and includes duplicates also. so 5 + 8 was 13
PRODUCT
	multiplication
	also called as cartesian product
	whenever we use JOINs, without join condition, we get this cartesian product
	also done using CROSS JOIN
MINUS
	all records of first result minus the common between the second
INTERSECT
	COMMON rows found in both relations





SELECT * FROM HR.DEPARTMENTS WHERE MANAGER_ID>110
    UNION ALL
SELECT * FROM HR.DEPARTMENTS WHERE MANAGER_ID<130;

SELECT * FROM HR.DEPARTMENTS WHERE MANAGER_ID>110
    minus
SELECT * FROM HR.DEPARTMENTS WHERE MANAGER_ID<130;

SELECT * FROM HR.DEPARTMENTS WHERE MANAGER_ID>110
    intersect
SELECT * FROM HR.DEPARTMENTS WHERE MANAGER_ID<130;

SELECT syntax
	SELECT COL1, COL2, .....
	FROM TABLE1, TABLE2,....
	[WHERE CONDITION1 AND|OR CONDITION....]
	[GROUP BY EXP] HAVING EXP]
	[ORDER BY EXP]
	


SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, SALARY*.1 "Bonus" 
    FROM HR.EMPLOYEES;

where clause
------------------
is used for SELECTION

SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, SALARY*.1 "Bonus" 
    FROM HR.EMPLOYEES
	WHERE SALARY>15000

What are the operators that can be used here?
	i used > operator
Task:
Identify as many operators in sql
+, -, *, /, 
-
+

>, <, >=, <=,

not equal to can be either != 		or 	<>

NOT
AND
OR

BETWEEN
NOT BETWEEN

LIKE 
NOT LINE

IN 
NOT IN

SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, SALARY- 2 "Bonus" 
    FROM HR.EMPLOYEES
	WHERE SALARY NOT BETWEEN 15000 AND 25000

SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, SALARY- 2 "Bonus" 
    FROM HR.EMPLOYEES
	WHERE FIRST_NAME LIKE 'D%'

SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, SALARY- 2 "Bonus" 
    FROM HR.EMPLOYEES
	WHERE FIRST_NAME LIKE 'A%a'

LIKE operator uses wild card characters
	%
	_

% means, 0 or more characters
_ means, 1 character


SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, SALARY- 2 "Bonus" 
    FROM HR.EMPLOYEES
	WHERE SALARY IN (1000, 2000, 3000, 4000, 5000, 6000, 7000)

LOGICAL operators
AND
OR
can be used when there are multiple conditions

SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, SALARY- 2 "Bonus" 
    FROM HR.EMPLOYEES
	WHERE SALARY IN (1000, 2000, 3000, 4000, 5000, 6000, 7000)
	AND EMPLOYEE_ID<170

-----------------------------------------------------------------------
pending: FUNCTIONS
ORDER BY clause:
--------------------------
is used to sort the result by expression


select * from hr.employees
order by department_id desc, manager_id;

asc for ascending
desc for descending
and no mention means, asc


how to extract year from date?

Problem #1:
Write a query to display the customer number , firstname, customer’s date of birth . Display in a sorted order of date of birth year and within that sort by firstname.
select CUSTID, FNAME, dob from customer
order by to_char(dob, 'yyyy'), fname;


Problem #2:
Write a query to display customer’s number, first name and middle name. The customer’s who don’t have middle name, for them display the last name. Give the alias name as Cust_Name.

solution 1:
select custid, fname || ' ' || mname Cust_Name from customer
where mname is not null
union
select custid, fname || ' ' || ltname Cust_Name from customer
where mname is null;


we can also use NULL functions 
what are the null functions:

NVL
NVL2
COALESCE


solution 2:	(using NVL)
select custid, fname || ' ' || NVL(mname, ltname) Cust_Name from customer
solution 3:	(using NVL2)
select custid, fname || ' ' || NVL2(mname, mname, ltname) Cust_Name from customer
solution 4: (using COALESCE)
select custid, fname || ' ' || COALESCE(mname, ltname) Cust_Name from customer
 

-------------------------------------
FUNCTIONS
-------------------
What are the functions you already know
	NVL
	NVL2
	COALESCE
	TO_CHAR
	TO_DATE
	TO_NUMBER
	MOD
	
Among these, the following are conversion functions
	TO_CHAR
	TO_NUMBER
	TO_DATE

TO_CHAR
	converts numbers or dates to CHAR type
	select TO_CHAR(123456789.5,'FM99,99,99,999.00') from dual;

TO_DATE
	converts char into date

TO_NUMBER
	converts char into number

Functions can be 
	Single row function (or)
	Aggregate function

select FNAME, UPPER(FNAME) FROM CUSTOMER;
SELECT SUM(TRANSACTION_AMOUNT) FROM TRANDETAILS;

----------------------------------------
What are aggregate functions?
	functions that return aggregate value per relation or per group
what is per relation?
	SELECT SUM(TRANSACTION_AMOUNT) FROM TRANDETAILS;
	in this example, you got 1 result per table (relation)
per relation or
per group

SELECT DEPARTMENT_ID, SUM(SALARY), MIN(SALARY), MAX(SALARY), COUNT(SALARY) FROM HR.EMPLOYEES
GROUP BY DEPARTMENT_ID;

SELECT COUNT(COMMISSION_PCT) FROM HR.EMPLOYEES;

Challenge
--------------
	display employee id, first name, salary, commission pct, bonus
	bonus is salary * commission pct
	if commission pct is null, then it is considered as .2

hint:
use HR.EMPLOYEES table in live sql

Solution:
select employee_id, first_name, salary, commission_pct, salary * NVL(commission_pct,.2) Bonus
from hr.employees;

Aggregation functions:
	MIN
	MAX
	SUM
	AVG
	COUNT

What is group by?
	GROUP by is used to get 1 aggregate result per GROUP
	
challenge:
SELECT DEPARTMENT_ID, AVG(SALARY) FROM HR.EMPLOYEES
GROUP BY DEPARTMENT_ID;

in the above query, modify so that, only departments where the average salary is above 9000


SELECT DEPARTMENT_ID, AVG(SALARY) FROM HR.EMPLOYEES
GROUP BY DEPARTMENT_ID
HAVING AVG(SALARY)>9000;

What is the difference between	WHERE and HAVING?


Activity
	identify the use of
		ROLLUP
		CUBE
	in GROUP BY

SELECT DEPARTMENT_ID, MANAGER_ID, COUNT(EMPLOYEE_ID) FROM HR.EMPLOYEES
GROUP BY rollup(DEPARTMENT_ID, MANAGER_ID)


SELECT DEPARTMENT_ID, MANAGER_ID, COUNT(EMPLOYEE_ID) FROM HR.EMPLOYEES
GROUP BY CUBE(DEPARTMENT_ID, MANAGER_ID)

DISTINCT
	is used to display or return each row only once

--------------------------------------------

JOIN
-------
1990s syntax is theta join
later JOIN syntax was introduced

theta join

display EMPLOYEE_ID, FIRST_NAME, DEPARTMENT_ID, DEPARTMENT NAME
from whatever tables required.

SELECT EMPLOYEE_ID, FIRST_NAME, E.DEPARTMENT_ID, DEPARTMENT_NAME 
    FROM HR.EMPLOYEES E, HR.DEPARTMENTS D
	WHERE E.DEPARTMENT_ID=D.DEPARTMENT_ID;

Observation:
	HR.EMPLOYEES table has 107 records
	but the above query returned only 106 records. 
	An employee "Kimberely Grant" does not have department id (ie., department_id is null)
	as per join condition, only rows that meet the join condition will be displayed, but 
	null department_id does not match with any row in HR.DEPARTMENTS table.

This type of join is called as INNER join.

SELECT EMPLOYEE_ID, FIRST_NAME, D.DEPARTMENT_ID, DEPARTMENT_NAME 
    FROM HR.EMPLOYEES E, HR.DEPARTMENTS D
	WHERE E.DEPARTMENT_ID(+)=D.DEPARTMENT_ID;

-- select * from hr.departments;

LEFT OUTER JOIN
	all rows from left side table and matching rows from right side table
	if no matching then null


RIGHT OUTER JOIN
	all rows from right side table and matching rows from left side table
	if no matching then null

FULL OUTER JOIN
	all rows from left table and matching rows from right side table
	all rows from right side table and matching rows from left side table
	this is not possible in theta join

JOIN syntax for joins
----------------------------
SELECT EMPLOYEE_ID, FIRST_NAME, D.DEPARTMENT_ID, DEPARTMENT_NAME 
    FROM HR.EMPLOYEES E JOIN HR.DEPARTMENTS D
	ON E.DEPARTMENT_ID=D.DEPARTMENT_ID;

The above is INNER JOIN

SELECT EMPLOYEE_ID, FIRST_NAME, D.DEPARTMENT_ID, DEPARTMENT_NAME 
    FROM HR.EMPLOYEES E LEFT JOIN HR.DEPARTMENTS D
	ON E.DEPARTMENT_ID=D.DEPARTMENT_ID;

The above is LEFT OUTER JOIN

SELECT EMPLOYEE_ID, FIRST_NAME, D.DEPARTMENT_ID, DEPARTMENT_NAME 
    FROM HR.EMPLOYEES E RIGHT OUTER JOIN HR.DEPARTMENTS D
	ON E.DEPARTMENT_ID=D.DEPARTMENT_ID;

The above is RIGHT OUTER JOIN

SELECT EMPLOYEE_ID, FIRST_NAME, D.DEPARTMENT_ID, DEPARTMENT_NAME 
    FROM HR.EMPLOYEES E FULL OUTER JOIN HR.DEPARTMENTS D
	ON E.DEPARTMENT_ID=D.DEPARTMENT_ID;

The above is FULL OUTER JOIN

Task:
------