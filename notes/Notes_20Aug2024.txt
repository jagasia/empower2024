Yesterday, we learned 
DDL
DML
DCL
TCL

Today, we learn DQL
Data Query Language
Data Retrieval Language
SELECT statement
	to retrieve data from the table(s)

yesterday we used simple SELECT statements
	
ex:
	SELECT * FROM PRODUCT;

What is this *?
	all columns

SELECT * FROM PRODUCT
	retrieves all rows and all columns
	but * means all columns

	we get all rows, because, we haven't specified any condition

SELECT * FROM PRODUCT WHERE ID=23;
	//here, we retrieve rows where ID is 23

Relational Operators:
------------------------------
PROJECTION
	projecting only the relevant columns
SELECTION
	selecting only the relevant rows
UNION
	combining rows from 2 relation, and common rows are shown only once
	duplicates are displayed only once, so 5 + 8 was 11	(2 duplicates)
UNION ALL
	combining rows from 2 relation, and includes duplicates also. so 5 + 8 was 13
PRODUCT
	multiplication
	also called as cartesian product
	whenever we use JOINs, without join condition, we get this cartesian product
	also done using CROSS JOIN
MINUS
	all records of first result minus the common between the second
INTERSECT
	COMMON rows found in both relations





SELECT * FROM HR.DEPARTMENTS WHERE MANAGER_ID>110
    UNION ALL
SELECT * FROM HR.DEPARTMENTS WHERE MANAGER_ID<130;

SELECT * FROM HR.DEPARTMENTS WHERE MANAGER_ID>110
    minus
SELECT * FROM HR.DEPARTMENTS WHERE MANAGER_ID<130;

SELECT * FROM HR.DEPARTMENTS WHERE MANAGER_ID>110
    intersect
SELECT * FROM HR.DEPARTMENTS WHERE MANAGER_ID<130;

SELECT syntax
	SELECT COL1, COL2, .....
	FROM TABLE1, TABLE2,....
	[WHERE CONDITION1 AND|OR CONDITION....]
	[GROUP BY EXP] HAVING EXP]
	[ORDER BY EXP]
	


SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, SALARY*.1 "Bonus" 
    FROM HR.EMPLOYEES;

where clause
------------------
is used for SELECTION

SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, SALARY*.1 "Bonus" 
    FROM HR.EMPLOYEES
	WHERE SALARY>15000

What are the operators that can be used here?
	i used > operator
Task:
Identify as many operators in sql
+, -, *, /, 
-
+

>, <, >=, <=,

not equal to can be either != 		or 	<>

NOT
AND
OR

BETWEEN
NOT BETWEEN

LIKE 
NOT LINE

IN 
NOT IN

SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, SALARY- 2 "Bonus" 
    FROM HR.EMPLOYEES
	WHERE SALARY NOT BETWEEN 15000 AND 25000

SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, SALARY- 2 "Bonus" 
    FROM HR.EMPLOYEES
	WHERE FIRST_NAME LIKE 'D%'

SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, SALARY- 2 "Bonus" 
    FROM HR.EMPLOYEES
	WHERE FIRST_NAME LIKE 'A%a'

LIKE operator uses wild card characters
	%
	_

% means, 0 or more characters
_ means, 1 character


SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, SALARY- 2 "Bonus" 
    FROM HR.EMPLOYEES
	WHERE SALARY IN (1000, 2000, 3000, 4000, 5000, 6000, 7000)

LOGICAL operators
AND
OR
can be used when there are multiple conditions

SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, SALARY- 2 "Bonus" 
    FROM HR.EMPLOYEES
	WHERE SALARY IN (1000, 2000, 3000, 4000, 5000, 6000, 7000)
	AND EMPLOYEE_ID<170

-----------------------------------------------------------------------
pending: FUNCTIONS
ORDER BY clause:
--------------------------
is used to sort the result by expression


select * from hr.employees
order by department_id desc, manager_id;

asc for ascending
desc for descending
and no mention means, asc


how to extract year from date?

Problem #1:
Write a query to display the customer number , firstname, customer’s date of birth . Display in a sorted order of date of birth year and within that sort by firstname.
select CUSTID, FNAME, dob from customer
order by to_char(dob, 'yyyy'), fname;


Problem #2:
Write a query to display customer’s number, first name and middle name. The customer’s who don’t have middle name, for them display the last name. Give the alias name as Cust_Name.

solution 1:
select custid, fname || ' ' || mname Cust_Name from customer
where mname is not null
union
select custid, fname || ' ' || ltname Cust_Name from customer
where mname is null;


we can also use NULL functions 
what are the null functions:

NVL
NVL2
COALESCE


solution 2:	(using NVL)
select custid, fname || ' ' || NVL(mname, ltname) Cust_Name from customer
solution 3:	(using NVL2)
select custid, fname || ' ' || NVL2(mname, mname, ltname) Cust_Name from customer
solution 4: (using COALESCE)
select custid, fname || ' ' || COALESCE(mname, ltname) Cust_Name from customer
 

-------------------------------------
FUNCTIONS
-------------------
What are the functions you already know
	NVL
	NVL2
	COALESCE
	TO_CHAR
	TO_DATE
	TO_NUMBER
	MOD
	
Among these, the following are conversion functions
	TO_CHAR
	TO_NUMBER
	TO_DATE

TO_CHAR
	converts numbers or dates to CHAR type
	select TO_CHAR(123456789.5,'FM99,99,99,999.00') from dual;

TO_DATE
	converts char into date

TO_NUMBER
	converts char into number

Functions can be 
	Single row function (or)
	Aggregate function

select FNAME, UPPER(FNAME) FROM CUSTOMER;
SELECT SUM(TRANSACTION_AMOUNT) FROM TRANDETAILS;

----------------------------------------
What are aggregate functions?
	functions that return aggregate value per relation or per group
what is per relation?
	SELECT SUM(TRANSACTION_AMOUNT) FROM TRANDETAILS;
	in this example, you got 1 result per table (relation)
per relation or
per group

SELECT DEPARTMENT_ID, SUM(SALARY), MIN(SALARY), MAX(SALARY), COUNT(SALARY) FROM HR.EMPLOYEES
GROUP BY DEPARTMENT_ID;

SELECT COUNT(COMMISSION_PCT) FROM HR.EMPLOYEES;

Challenge
--------------
	display employee id, first name, salary, commission pct, bonus
	bonus is salary * commission pct
	if commission pct is null, then it is considered as .2

hint:
use HR.EMPLOYEES table in live sql

Solution:
select employee_id, first_name, salary, commission_pct, salary * NVL(commission_pct,.2) Bonus
from hr.employees;

Aggregation functions:
	MIN
	MAX
	SUM
	AVG
	COUNT

What is group by?
	GROUP by is used to get 1 aggregate result per GROUP
	
challenge:
SELECT DEPARTMENT_ID, AVG(SALARY) FROM HR.EMPLOYEES
GROUP BY DEPARTMENT_ID;

in the above query, modify so that, only departments where the average salary is above 9000


SELECT DEPARTMENT_ID, AVG(SALARY) FROM HR.EMPLOYEES
GROUP BY DEPARTMENT_ID
HAVING AVG(SALARY)>9000;

What is the difference between	WHERE and HAVING?


Activity
	identify the use of
		ROLLUP
		CUBE
	in GROUP BY

SELECT DEPARTMENT_ID, MANAGER_ID, COUNT(EMPLOYEE_ID) FROM HR.EMPLOYEES
GROUP BY rollup(DEPARTMENT_ID, MANAGER_ID)


SELECT DEPARTMENT_ID, MANAGER_ID, COUNT(EMPLOYEE_ID) FROM HR.EMPLOYEES
GROUP BY CUBE(DEPARTMENT_ID, MANAGER_ID)

DISTINCT
	is used to display or return each row only once

--------------------------------------------

JOIN
-------
1990s syntax is theta join
later JOIN syntax was introduced

theta join

display EMPLOYEE_ID, FIRST_NAME, DEPARTMENT_ID, DEPARTMENT NAME
from whatever tables required.

SELECT EMPLOYEE_ID, FIRST_NAME, E.DEPARTMENT_ID, DEPARTMENT_NAME 
    FROM HR.EMPLOYEES E, HR.DEPARTMENTS D
	WHERE E.DEPARTMENT_ID=D.DEPARTMENT_ID;

Observation:
	HR.EMPLOYEES table has 107 records
	but the above query returned only 106 records. 
	An employee "Kimberely Grant" does not have department id (ie., department_id is null)
	as per join condition, only rows that meet the join condition will be displayed, but 
	null department_id does not match with any row in HR.DEPARTMENTS table.

This type of join is called as INNER join.

SELECT EMPLOYEE_ID, FIRST_NAME, D.DEPARTMENT_ID, DEPARTMENT_NAME 
    FROM HR.EMPLOYEES E, HR.DEPARTMENTS D
	WHERE E.DEPARTMENT_ID(+)=D.DEPARTMENT_ID;

-- select * from hr.departments;

LEFT OUTER JOIN
	all rows from left side table and matching rows from right side table
	if no matching then null


RIGHT OUTER JOIN
	all rows from right side table and matching rows from left side table
	if no matching then null

FULL OUTER JOIN
	all rows from left table and matching rows from right side table
	all rows from right side table and matching rows from left side table
	this is not possible in theta join

JOIN syntax for joins
----------------------------
SELECT EMPLOYEE_ID, FIRST_NAME, D.DEPARTMENT_ID, DEPARTMENT_NAME 
    FROM HR.EMPLOYEES E JOIN HR.DEPARTMENTS D
	ON E.DEPARTMENT_ID=D.DEPARTMENT_ID;

The above is INNER JOIN

SELECT EMPLOYEE_ID, FIRST_NAME, D.DEPARTMENT_ID, DEPARTMENT_NAME 
    FROM HR.EMPLOYEES E LEFT JOIN HR.DEPARTMENTS D
	ON E.DEPARTMENT_ID=D.DEPARTMENT_ID;

The above is LEFT OUTER JOIN

SELECT EMPLOYEE_ID, FIRST_NAME, D.DEPARTMENT_ID, DEPARTMENT_NAME 
    FROM HR.EMPLOYEES E RIGHT OUTER JOIN HR.DEPARTMENTS D
	ON E.DEPARTMENT_ID=D.DEPARTMENT_ID;

The above is RIGHT OUTER JOIN

SELECT EMPLOYEE_ID, FIRST_NAME, D.DEPARTMENT_ID, DEPARTMENT_NAME 
    FROM HR.EMPLOYEES E FULL OUTER JOIN HR.DEPARTMENTS D
	ON E.DEPARTMENT_ID=D.DEPARTMENT_ID;

The above is FULL OUTER JOIN

Task:
------
Bank_Hands_on_set1
Kindly start solving from the above file


Problem #3:
Write a query to display account number, customer’s number, customer’s firstname,lastname,account opening date.


Solution:
select a.acnumber, a.custid, c.fname, c.ltname, a.aod 
    from account a join customer c
    on a.custid=c.custid;

Problem # 4:
Write a query to display the number of customer’s from Delhi. Give the count an alias name of Cust_Count.

Solution:
SELECT COUNT(*) Cust_Count FROM CUSTOMER
    WHERE CITY='Delhi';


Problem # 5:
Write a query to display  the customer number, customer firstname,account number for the customer’s whose accounts were created after 15th of any month.

Solution:
SELECT c.custid, c.fname, a.acnumber--, a.aod, extract(day from a.aod)
FROM CUSTOMER c JOIN ACCOUNT a
ON c.custid=a.custid
WHERE extract(day from a.aod)>15;

Problem # 6:
Write a query to display the customers firstname, city and account number who are not into business, service or studies.

Solution:
SELECT C.FNAME, C.CITY, A.ACNUMBER, C.OCCUPATION
FROM CUSTOMER C JOIN ACCOUNT A
    ON C.CUSTID=A.CUSTID
WHERE C.OCCUPATION NOT IN('Business', 'Service', 'Student');

Problem # 7:
Write a query to display city name and count of branches in that city. Give the count of branches an alias name of Count_Branch.

The following rows were added recently, so the problem 7 result will differ
B00010	MG Road	Bengaluru
B00011	OMR	Chennai
B00012	New Branch	Coimbatore

Solution:
select BCITY, COUNT(BID) Count_Branch from branch
GROUP BY BCITY;

Problem # 8:
Write a query to display account id, customer’s firstname, customer’s lastname for the customer’s whose account is Active.

Solution:
SELECT A.ACNUMBER, C.FNAME, C.LTNAME FROM ACCOUNT A JOIN CUSTOMER C
    ON A.CUSTID=C.CUSTID
    WHERE ASTATUS='Active';


Sub Queries
----------------
Scenario

Find the first name of customers who belong to the city where Rahul belongs to.

SELECT FNAME FROM CUSTOMER WHERE CITY=(SELECT CITY FROM CUSTOMER WHERE FNAME='Rahul');

here, sub query was used 

INSERT INTO CUSTOMER VALUES('C00010','Rahul',null,'Dravid','Bengaluru','989898','Coach', '01-Jun-1972');

now,
SELECT FNAME FROM CUSTOMER WHERE CITY=(SELECT CITY FROM CUSTOMER WHERE FNAME='Rahul');
ORA-01427: single-row subquery returns more than one row


SELECT FNAME, CITY FROM CUSTOMER WHERE CITY IN(SELECT CITY FROM CUSTOMER WHERE FNAME='Rahul');




SELECT * FROM CUSTOMER C WHERE EXISTS
    (SELECT * FROM LOAN L WHERE L.CUSTID=C.CUSTID);
The above example shows use of a correlated sub query.
the sub query cannot be executed independently.
the sub query depends on outer query for execution/ existence.
that is called correlated sub query

EXIST operator


Task:
Identify the rules for sub queries
1) paranthesis (brackets) are used for sub queries
2) sub queries are used in right side of the expression with outer query
3) sub query returning more than one row must be used with 
	IN
	NOT IN
	EXISTS
	ANY
	ALL
operators
otherwise, sub query must return single row
4) the sub query select column must match with outer query condition except when EXISTS operator is used
5) sub query need not use ORDER BY except during TOP N analysis

TOP N analysis
---------------------
Display only the first row of a result. How to do?
SELECT * FROM CUSTOMER WHERE ROWNUM=1;

These top N analysis will not return all records when they have same value
For example, if the top 2 rows are equal, only 1 will be retrieved by ROWNUM=1

Challenge
----------------
Display the department which spends maximum amount for salary for their employees
explanation:
	each department has sum of salaries of their employees
	which sum is highest among the departments
display department id, and sum of salary

use HR.EMPLOYEES table
columns:
	department_id
	salary


SELECT DEPARTMENT_ID, SUM(SALARY) 
FROM HR.EMPLOYEES
GROUP BY DEPARTMENT_ID
HAVING SUM(SALARY)>=ALL(
    SELECT SUM(SALARY) 
FROM HR.EMPLOYEES
GROUP BY DEPARTMENT_ID
);

--------------------
Types of JOINs
1) INNER
2) OUTER
	LEFT
	RIGHT
	FULL
3) CROSS
4) NATURAL
5) SELF
6) NON EQUI JOIN

CROSS JOIN
--------------------
	is cartesian product
	5 rows in first table, 5 rows in second table, then 5 * 5 = 25 rows

HR.EMPLOYEES table has 9 rows (with our condition)
HR.DEPARTMENTS table has 27 rows

if we cross join these 2 tables, we will get 107 * 27 rows

9 * 27 = 243

SELECT * FROM HR.EMPLOYEES E CROSS JOIN HR.DEPARTMENTS D
    WHERE E.SALARY<10000 AND E.FIRST_NAME LIKE 'A%';

NATURAL JOIN
-----------------------
When 2 relations naturally have a common column, NATURAL JOIN can identify that and join
and avoids cross or cartesian product. 
If both relations having common column names also same, then we can use USING function.

SELECT * FROM ACCOUNT A NATURAL JOIN CUSTOMER C;
SELECT * FROM ACCOUNT A JOIN CUSTOMER C USING (CUSTID);


Challenge
	in HR.EMPLOYEES table, 
	we have EMPLOYEE_ID and MANAGER_ID
	Write a SELECT statement to display
	EMPLOYEE_ID
	FIRST_NAME of the employee
	MANAGER NAME 

HR.EMPLOYEES E		manager_id
HR.EMPLOYEES M		employee_id


SELECT E.EMPLOYEE_ID, E.FIRST_NAME, M.FIRST_NAME MANAGER_NAME
FROM HR.EMPLOYEES E LEFT JOIN HR.EMPLOYEES M
ON E.MANAGER_ID=M.EMPLOYEE_ID
    ORDER BY E.EMPLOYEE_ID;

The above query displays steven king also but he do not have manager id.
we get this using left outer join.

NON EQUI JOIN
------------------------
select * from hr.jobs;

JOB_ID	JOB_TITLE	MIN_SALARY	MAX_SALARY
AD_PRES	President	20080	40000
AD_VP	Administration Vice President	15000	30000
AD_ASST	Administration Assistant	3000	6000
FI_MGR	Finance Manager	8200	16000
FI_ACCOUNT	Accountant	4200	9000
AC_MGR	Accounting Manager	8200	16000
AC_ACCOUNT	Public Accountant	4200	9000
SA_MAN	Sales Manager	10000	20080
SA_REP	Sales Representative	6000	12008
PU_MAN	Purchasing Manager	8000	15000
PU_CLERK	Purchasing Clerk	2500	5500
ST_MAN	Stock Manager	5500	8500
ST_CLERK	Stock Clerk	2008	5000
SH_CLERK	Shipping Clerk	2500	5500
IT_PROG	Programmer	4000	10000
MK_MAN	Marketing Manager	9000	15000
MK_REP	Marketing Representative	4000	9000
HR_REP	Human Resources Representative	4000	9000
PR_REP	Public Relations Representative	4500	10500

NOW, hr.employees table has SALARY column
if you join EMPLOYEES with JOBS then what will be the join condition

e.salary between j.min_salary and j.max_salary;
we are using non equi join here.


SELECT E.EMPLOYEE_ID, E.FIRST_NAME, E.SALARY,
J.JOB_TITLE
FROM HR.EMPLOYEES E JOIN HR.JOBS J
ON E.SALARY BETWEEN J.MIN_SALARY AND J.MAX_SALARY;

----------------------------------
Problem # 9:
Write a query to display the customer’s number, customer’s firstname, branch id and loan amount for people who have taken loans.

select c.custid, c.fname, l.bid, l.loan_amount
from customer c join loan l
on c.custid=l.custid;

Problem # 10:
Write a query to display customer number, customer name, account number where the account status is terminated.

select c.custid, c.fname, a.acnumber
from customer c join account a
on c.custid=a.custid
where a.astatus='Terminated';

