What is Testing, Need of Testing, Types of Testings, What is J-Unit, Need of J-Unit, Programming with J-Unit
Testing
--------
in SDLC, testing comes after implementation (coding)
But the role of testers begin very early in the SDLC

SDLC	-	Software Development Life Cycle

RUP	-	Rational Unified Process

	INCEPTION
	ELABORATION
	CONSTRUCTION
	TRANSITION

Testing types:
	black box
		functional testing
			i will run the code with sample inputs and expected outputs.
			expected vs actual
	white box
		code quality

	regression testing

	stress testing

	integration testing

Junit
	unit testing
	an individual unit of code (a method) is tested


AUT	Application under test
SUT	Software under test

we will have a class that contains some methods

we will create another test class that tests these methods


test case
	tc number
	which method
	what are the arguments
	what is the expected output


test suites

test runners

Demo:
our CUT class under test is 
	Mathematics.java

our test class for this CUT is 
	MathematicsTest.java



BeforeClass
Before
AfterClass
After




Before
--------
	a method annotated with a @Before annotation is executed before every test method

BeforeClass
-----------
	a method annotated with a @BeforeClass is executed only once before the first test method
	before class method must be a static method


After
-------
	after every test method

AfterClass
-----
	after last test method




assert methods


TDD
	write the code to fail
	modify the code to pass
	refactor the code






package com.empower.demo.model;

public class Mathematics {
	public int sum(int i, int j)
	{
		return i+j;
	}
	
	public int difference(int i, int j)
	{
		return i-j;
	}
	
	public int product(int i, int j)
	{
		return i*j;
	}
	
}









/**
 * 
 */
package com.empower.demo.test;

import static org.junit.Assert.*;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

import com.empower.demo.model.Mathematics;

/**
 * 
 */
public class MathematicsTest {

	int x=0;
	int y=0;
	
	Mathematics maths=null;
	/**
	 * @throws java.lang.Exception
	 */
	@BeforeClass
	public static void setUpBeforeClass() throws Exception {
		System.out.println("Before class");
	}

	/**
	 * @throws java.lang.Exception
	 */
	@AfterClass
	public static void tearDownAfterClass() throws Exception {
		System.out.println("After class");
	}
	

	/**
	 * @throws java.lang.Exception
	 */
	@Before
	public void setUp() throws Exception {
		x=2;
		y=3;
		maths=new Mathematics();
		System.out.println("Before method is executed");
	}

	/**
	 * @throws java.lang.Exception
	 */
	@After
	public void tearDown() throws Exception {
		System.out.println("After method");
	}
	

	/**
	 * Test method for {@link com.empower.demo.model.Mathematics#sum(int, int)}.
	 */
	@Test
	public void testSum() {		
		int expected=5;
		int actuals=maths.sum(x, y);
		assertEquals(expected, actuals);
	}

	/**
	 * Test method for {@link com.empower.demo.model.Mathematics#difference(int, int)}.
	 */
	@Test
	public void testDifference() {
		int expected=-1;
		int actuals=maths.difference(x, y);
		assertEquals(expected, actuals);
	}

	/**
	 * Test method for {@link com.empower.demo.model.Mathematics#product(int, int)}.
	 */
	@Test
	public void testProduct() {
		int expected=6;
		int actuals=maths.product(x, y);
		assertEquals(expected, actuals);
	}

}



-----------------------
Task steps:
1) create a project
2) create aut		ex:	Mathematics.java
	with methods	ex:	sum, product, difference
3) create testing class	ex:	MathematicsTest.java

right click project -> New -> JUnitTestcase

	before, after, beforeClass, afterClass	(are optional)

	create test methods
		a method with @Test annotation is a test method


you can tick the before after methods
and "browse" for Mathematics class

Next -> choose 
	sum
	product
	difference

Finish

4) in test methods, 
	use assert methods

identify what are the types of 
	assert methods available

ex:
	assertEquals
	assertNotEquals
	assertNotNull
	assertSame

