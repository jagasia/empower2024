What is Testing, Need of Testing, Types of Testings, What is J-Unit, Need of J-Unit, Programming with J-Unit
Testing
--------
in SDLC, testing comes after implementation (coding)
But the role of testers begin very early in the SDLC

SDLC	-	Software Development Life Cycle

RUP	-	Rational Unified Process

	INCEPTION
	ELABORATION
	CONSTRUCTION
	TRANSITION

Testing types:
	black box
		functional testing
			i will run the code with sample inputs and expected outputs.
			expected vs actual
	white box
		code quality

	regression testing

	stress testing

	integration testing

Junit
	unit testing
	an individual unit of code (a method) is tested


AUT	Application under test
SUT	Software under test

we will have a class that contains some methods

we will create another test class that tests these methods


test case
	tc number
	which method
	what are the arguments
	what is the expected output


test suites

test runners

Demo:
our CUT class under test is 
	Mathematics.java

our test class for this CUT is 
	MathematicsTest.java



BeforeClass
Before
AfterClass
After




Before
--------
	a method annotated with a @Before annotation is executed before every test method

BeforeClass
-----------
	a method annotated with a @BeforeClass is executed only once before the first test method
	before class method must be a static method


After
-------
	after every test method

AfterClass
-----
	after last test method




assert methods


TDD
	write the code to fail
	modify the code to pass
	refactor the code






package com.empower.demo.model;

public class Mathematics {
	public int sum(int i, int j)
	{
		return i+j;
	}
	
	public int difference(int i, int j)
	{
		return i-j;
	}
	
	public int product(int i, int j)
	{
		return i*j;
	}
	
}









/**
 * 
 */
package com.empower.demo.test;

import static org.junit.Assert.*;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

import com.empower.demo.model.Mathematics;

/**
 * 
 */
public class MathematicsTest {

	int x=0;
	int y=0;
	
	Mathematics maths=null;
	/**
	 * @throws java.lang.Exception
	 */
	@BeforeClass
	public static void setUpBeforeClass() throws Exception {
		System.out.println("Before class");
	}

	/**
	 * @throws java.lang.Exception
	 */
	@AfterClass
	public static void tearDownAfterClass() throws Exception {
		System.out.println("After class");
	}
	

	/**
	 * @throws java.lang.Exception
	 */
	@Before
	public void setUp() throws Exception {
		x=2;
		y=3;
		maths=new Mathematics();
		System.out.println("Before method is executed");
	}

	/**
	 * @throws java.lang.Exception
	 */
	@After
	public void tearDown() throws Exception {
		System.out.println("After method");
	}
	

	/**
	 * Test method for {@link com.empower.demo.model.Mathematics#sum(int, int)}.
	 */
	@Test
	public void testSum() {		
		int expected=5;
		int actuals=maths.sum(x, y);
		assertEquals(expected, actuals);
	}

	/**
	 * Test method for {@link com.empower.demo.model.Mathematics#difference(int, int)}.
	 */
	@Test
	public void testDifference() {
		int expected=-1;
		int actuals=maths.difference(x, y);
		assertEquals(expected, actuals);
	}

	/**
	 * Test method for {@link com.empower.demo.model.Mathematics#product(int, int)}.
	 */
	@Test
	public void testProduct() {
		int expected=6;
		int actuals=maths.product(x, y);
		assertEquals(expected, actuals);
	}

}



-----------------------
Task steps:
1) create a project
2) create aut		ex:	Mathematics.java
	with methods	ex:	sum, product, difference
3) create testing class	ex:	MathematicsTest.java

right click project -> New -> JUnitTestcase

	before, after, beforeClass, afterClass	(are optional)

	create test methods
		a method with @Test annotation is a test method


you can tick the before after methods
and "browse" for Mathematics class

Next -> choose 
	sum
	product
	difference

Finish

4) in test methods, 
	use assert methods

identify what are the types of 
	assert methods available

ex:
	assertEquals
	assertNotEquals
	assertNotNull
	assertSame

----------
How to run the tests using main method?
import java.util.List;

import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.junit.runner.notification.Failure;

import com.empower.demo.test.MathematicsTest;

public class App {

	public static void main(String[] args) {
		Result result = JUnitCore.runClasses(MathematicsTest.class);
		List<Failure> failures = result.getFailures();
		for(Failure f :failures)
		{
			System.out.println(f.getMessage());
		}
	}

}


---------------------
Test Suite
----------
	What is a test suite?
		collection of test cases


Suppose we have lot of test classes
	MathematicsTest.java
	MathematicsTest2.java
	MathematicsTest3.java
	MathematicsTest4.java
	MathematicsTest4.java


we can create a test suite and mention the test classes that belong to the suite and
	run the test suite

using test runner


@Ignore




Test Runner types:
	Suite
	Categories
	Parameterized


package com.empower.demo.test;

import org.junit.runner.RunWith;
import org.junit.runners.Suite;
import org.junit.runners.Suite.SuiteClasses;

@RunWith(Suite.class)
@SuiteClasses({MathematicsTest.class, MathematicsTest2.class, MathematicsTest5.class})
public class AppSuite {

}


--------------------------------------
What is categorized

to create category, create interfaces



package com.empower.demo.test;

import org.junit.experimental.categories.Categories;
import org.junit.experimental.categories.Categories.ExcludeCategory;
import org.junit.experimental.categories.Categories.IncludeCategory;
import org.junit.experimental.categories.Category;
import org.junit.runner.RunWith;
import org.junit.runners.Suite;
import org.junit.runners.Suite.SuiteClasses;

@RunWith(Categories.class)
@SuiteClasses({MathematicsTest.class, MathematicsTest2.class, MathematicsTest5.class})
//@IncludeCategory({Admin.class})
@ExcludeCategory({Admin.class})
public class AppSuite {

}




-----------------------------------------------------------------
Parameterized
	we want to use one test class that can be instantiated for 
		lot of test cases

we can keep those test cases in an array list
and for each element in arraylist, the same test class is instantiated and repeatedly executed.


Demo:
Mathematics.java
-----------------
package com.empower.demo.model;

public class Mathematics {
	
	int no1;
	int no2;
	int expected;
	public Mathematics(int no1, int no2, int expected)
	{
		this.no1=no1;
		this.no2=no2;
		this.expected=expected;
	}
	
	public int sum()
	{
		return no1+no2;
	}
	
	public int difference()
	{
		return no1-no2;
	}
	
	public int product()
	{
		return no1*no2;
	}
	
}






MathematicsTest.java

package com.empower.demo.test;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.fail;

import java.util.Arrays;
import java.util.Collection;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;

import com.empower.demo.model.Mathematics;

@RunWith(Parameterized.class)
public class MathematicsTest {
	Mathematics maths=null;
	
	int no1, no2, expectedResult;
	
	public MathematicsTest(int no1, int no2, int expectedResult)
	{
		this.no1=no1;
		this.no2=no2;
		this.expectedResult=expectedResult;
	}

	@BeforeClass
	public static void setUpBeforeClass() throws Exception {
	}

	@AfterClass
	public static void tearDownAfterClass() throws Exception {
	}

	@Before
	public void setUp() throws Exception {
		maths=new Mathematics(no1, no2, expectedResult);
		System.out.printf("Running the test using %d, %d, %d\n",no1, no2, expectedResult);
	}

	@After
	public void tearDown() throws Exception {
	}

	@Test
	public void testSum() {
		int actual = maths.sum();
		assertEquals(actual, expectedResult);
	}

	@Parameterized.Parameters
	public static Collection anything()
	{
		return Arrays.asList(new Object[][] {
			 { 2, 3, 5 },
	         { 6, 3, 9 },
	         { 19, 1, 20 },
	         { 22, 1, 23 },
	         { 23, 1, 24 },
	         {1,2,3},
	         { 2, 11, 13 },
	         { 21, 1, 22 }
		});
	}
	
}




