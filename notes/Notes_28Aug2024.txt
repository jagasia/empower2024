IO
	Input
	Output



list the type of files
	jpg
	csv
	png
	mp3
	mp4
	mkv
	pdf
	xls
	doc
	

	txt



characters
binary

input = read
output = write


if program reads characters, then it uses "Reader"s
if program writes characters, then it uses "Writer"s

if program reads bytes, then it uses "InputStream"s
if program writes bytes, then it uses "OutputStream"s


in java.io package
	there are several classes


FileInputStream
FileWriter

there are some streams=> node streams
there are some filter streams that work on node stream


node stream
	reads/ writes from / to a definite node

	FileInputStream, FileReader, FileOutputStream, FileWriter are example for node streams


filterstreams work on other streams to provide some functionality

BufferedReader
BufferedWriter
BufferedInputStream
BufferedOutputStream

DataInputStream				read primitive type data from source
DataOutputStream				write primitive type data to target

ObjectInputStream
ObjectOutputStream



import java.io.BufferedInputStream;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class App2 {

	public static void main(String[] args) throws IOException {
		//read chars from keyboard
		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
//		BufferedInputStream bis=new BufferedInputStream(System.in);
//		char c=(char) br.read();
//		System.out.println("Your input is "+c);
		
		String input = br.readLine();
		System.out.println(input);
	}

}





		BufferedReader br=new BufferedReader(new FileReader("nitin.txt"));
		String input = br.readLine();
		System.out.println(input);

java.io 
	File




import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;

public class AppFileCopy {

	public static void main(String[] args) throws IOException {
		File f=new File("C:\\Users\\rjaga\\Pictures\\pizza1.jfif");
		long len = f.length();
		byte []data=new byte[(int) len];
		FileInputStream fis=new FileInputStream(f);
		fis.read(data);
		fis.close();
		
		//write all the bytes to a new file
		File f1=new File("guru.jfif");
		FileOutputStream fos=new FileOutputStream(f1);
		fos.write(data);
		fos.flush();
		fos.close();
	}

}






If you write an object into a stream, this is called as "Serialization"




Problem:		when i write an object of Employee to a stream, i get following error:
Exception in thread "main" java.io.NotSerializableException: Employee
	at java.base/java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:1187)
	at java.base/java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:350)
	at AppObjectOutputDemo.main(AppObjectOutputDemo.java:15)


Solution:
class Employee implements Serializable



Task:
--------
create a java program to display all files present in a given location

hint:
	File class provides methods 
		list()		returns String[]		the name of files and folders
		listFiles()		returns File[]		the array of File objects

use listFiles() method and get array of File and
	check each element if it is a file or folder
	and display only file
	or display only folders

Activity:
Identify the purpose of each class

File

FileReader
FileWriter

FileInputStream
FileOutputStream		

BufferedReader
BufferedWriter
BufferedInputStream
BufferedOutputStream

DataInputStream				
DataOutputStream				

ObjectInputStream
ObjectOutputStream




BufferedReader br=new BufferedReader(fr);		//fr is object of FileReader

--------------------------------------------
Multi-Threading
-----------------
So far, you have created lot of java programs, can you tell me how many threads were there in your programs?
	1

any program which has main method, can be executed.

Employee class, doesn't have a main method.



When we execute a program,
	it becomes a process for the cpu

Process is a running instance of a program

CPU allocates resources for each process
	resource means?
		time
		memory


A process can contain thread(s)
	main method is the beginning of the flow of execution
	so main method becomes a "main" thread


	so far, we executed lot of programs, each became process
		single threaded process.

	if we add child threads, then they become
		multi-threaded process


What is the need for multithreading?
	the CPU time, can be utilized effectively by using multi-threading

2.3 GHz
	1/time

	for 1 second		2.3 * 1024 * 1024 * 1024

1 thread
	0 %

2 thread
	50 %

3 thread
	66 %

4 thread
	75 %


what is performance?
	effective utilization of resources



2 work using 2 processes?
	cpu allocates resource for each process

2 works using 1 process , 2 threads inside the 1 process
	cpu allocates resource for process only
		threads share the resources of the process


advantages of multi threading:
	1) improves performance
	2) concurrency/ parallelism




How to create child threads?
	i)	extends Thread
	ii) 	implements Runnable


demo1:
	extends Threads

class Odd extends Thread
{
	public void run()
	{
		for(int i=1;i<30;i+=2)
		{
			System.out.println(Thread.currentThread().getName()+": "+i);
			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	}
}

class Even extends Thread
{
	public void run()
	{
		for(int i=2;i<30;i+=2)
		{
			System.out.println(getName()+": "+i);
			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	}
}


public class App {

	public static void main(String[] args) {
		Odd o=new Odd();
		o.setName("Odd thread");
		Even e=new Even();
		e.setName("Even thread");
		
		o.start();
		e.start();
		

	}

}



-----------------------------------------
ii) implements Runnable

class Black implements Runnable
{
	public void run()
	{
		for(int i=0;i<20;i++)
		{
			System.out.println("Black");
			try {
				Thread.sleep(100);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	}
}

class White implements Runnable
{
	public void run()
	{
		for(int i=0;i<20;i++)
		{
			System.out.println("WHite");
			try {
				Thread.sleep(500);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	}
}


public class App2 {

	public static void main(String[] args) {
		Thread t1=new Thread(new Black());
		Thread t2=new Thread(new White());
		
		t1.start();
		t2.start();

	}

}


Task:
-----------
1) Java PF coding challenges
2) Java Mock 11	OOPS requirements 1- 6
3) IO streams
4) Multi threading

------------------------------------------------------------
Thread methods:
	start()
	wait()
	notify()
	notifyAll()
	yield()
	join()
	


Life cycle of thread
	when we create a thread				new thread state
	when we call the start method			runnable state
	when a thread is sleeping, blocked by another thread, 	not runnable state
	when a thread completes the work of run method		dead state
	when the process that contains the thread is killed	dead state



	
wait() vs sleep()
	sleep has time limit			milliseconds
	wait 		waits until notify

notify
notifyAll
	can bring thread(s) to runnable stte

yield
	will make the current monitor to give up the monitor and choose a thread arbitrarily the monitor

join
	ensures, the currently running threads to continue but all other threads (which are yet to start) to wait untile
	started threads complete




class MyThread extends Thread
{

	@Override
	public void run() {
		for(int i=0;i<10;i++)
		{
			System.out.println(Thread.currentThread().getName()+":"+i);
			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	}
	
}



public class App {

	public static void main(String[] args) throws InterruptedException {
		MyThread t0=new MyThread();
		MyThread t1=new MyThread();
		MyThread t2=new MyThread();
		MyThread t3=new MyThread();
		MyThread t4=new MyThread();
		
		t0.start();
		t1.start();
		t2.start();
		t1.join();	
		t3.start();
		t4.start();
		
		
		
		
	}

}



Synchronization
------------------
	ensures that that no two threads allowed to access a shared resource at a time


	either the entire method can be synchronized
	or
	a portion of the method can be synchronized



disadvantages of multi-threading:
	Race condition			cannot predict the order of outcome
	Lock starvation			low priority thread waits for its turn
	Dead lock				both thread wait for each other


---------------------------------------------
Project
	should be a web application
	ReactJs front end
	Sprint boot microservices back end
	Oracle database

